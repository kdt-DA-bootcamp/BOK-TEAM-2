# -*- coding: utf-8 -*-
"""ROCcurve.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uu6UmHTLGhXT1snJA0aOn2jZZ65Kevwo
"""

# 기존에 문서 재현율 구하는 것에서 threshold만 바꿔가면서 재현율 / 위양성율을 구하거나
# 표를 만들고 -> 그래프 만들고 -> 정적분까지
from datetime import datetime
import pandas as pd
from dateutil.relativedelta import relativedelta

# date로 전환
call_rate = pd.read_csv('/content/drive/MyDrive/BOK-TEAM-2/Evaluation/call_rate.csv')
call_rate['시점'] = pd.to_datetime(call_rate['시점'], format = '%Y%m%d').dt.date

doc_scores = pd.read_csv('/content/drive/MyDrive/BOK-TEAM-2/Evaluation/ngram문서단위감성점수계산.csv')
doc_scores['date'] = pd.to_datetime(doc_scores['date']).dt.date


filter_doc_scores = pd.read_csv('/content/drive/MyDrive/BOK-TEAM-2/Evaluation/filter_ngram문서단위감성점수계산.csv')
filter_doc_scores['date'] = pd.to_datetime(filter_doc_scores['date']).dt.date

#############################
# answer (실제 콜금리 데이터)
# 날짜 정렬 (이진 탐색을 위해 정렬 필요)
call_rate = call_rate.sort_values('시점').reset_index(drop=True)

# 금리 변화 라벨링
label = []
call_rate_dates = call_rate['시점'].values  # numpy 배열로 변환 (검색 최적화)

for date in doc_scores['date']:
    next_month_date = date + relativedelta(months=1)

    # 현재 날짜의 콜금리 찾기 (이전 날짜 중 가장 가까운 날짜)
    idx_start = call_rate_dates.searchsorted(date, side='right') - 1  # date 이하에서 가장 가까운 날짜
    if idx_start >= 0:  # 유효한 인덱스인지 확인
        start_date = call_rate_dates[idx_start]
        start = call_rate.loc[call_rate['시점'] == start_date, '값'].iloc[0]
    else:
        start = None  # 해당 날짜 이전 값이 없는 경우

    # 한 달 뒤 날짜의 콜금리 찾기 (이전 날짜 중 가장 가까운 날짜)
    idx_end = call_rate_dates.searchsorted(next_month_date, side='right') - 1  # next_month_date 이하에서 가장 가까운 날짜
    if idx_end >= 0:  # 유효한 인덱스인지 확인
        end_date = call_rate_dates[idx_end]
        end = call_rate.loc[call_rate['시점'] == end_date, '값'].iloc[0]
    else:
        end = None  # 해당 날짜 이전 값이 없는 경우

    # print(start, end)
    # 금리 비교 후 라벨링
    if start is not None and end is not None:
        if start > end:
            label.append(-1)  # 금리 하락
        elif start < end:
            label.append(1)  # 금리 상승
        else:
            label.append(0)  # 금리 동일
    else:
        label.append(None)  # 비교할 데이터가 부족한 경우

# label을 다른 df에 붙이기
doc_scores['answer'] = label
filter_doc_scores['answer'] = label
#############################

# threshold 저장
# 너무 작은 값은 만들어지지 않도록, 절댓값 0.05 이하는 0으로 처리
doc_predict = doc_scores.copy()
filter_doc_predict = filter_doc_scores.copy()

def use_threshold(df, column, threshold:float):
    df['pred'] = df[column].apply(lambda x : 1 if x > threshold else (-1 if x < threshold else 0))
    return df

# 정확도
accuracy = sum(doc_predict['tone_i_ft'] == doc_predict['answer']) / len(doc_predict)
print(f'Accuracy: {accuracy}')

##### 수치 측정 함수 #####
# 재현율
def recall(pred, true, label):
    tp = sum(1 for i in range(len(pred)) if pred[i] == label and true[i] == label)
    fn = sum(1 for i in range(len(pred)) if pred[i] != label and true[i] == label)
    return tp / (tp + fn) if (tp + fn) > 0 else 0

# 위양성율 (False Positive Rate, FPR)
def false_positive_rate(pred, true, label):
    fp = sum(1 for i in range(len(pred)) if pred[i] == label and true[i] != label)  # False Positive
    tn = sum(1 for i in range(len(pred)) if pred[i] != label and true[i] != label)  # True Negative
    return fp / (fp + tn) if (fp + tn) > 0 else 0
####################

import pandas as pd
import numpy as np

tone_cols = ['tone_i_n2v', 'tone_i_ft', 'tone_i_nb1', 'tone_i_nb2', 'tone_i_kosac']
thresholds = np.arange(0, 1.0001, 0.0001)  # 0부터 1까지 0.0001 간격으로 생성 (즉, 1만개의 point를 만듦)

results = []

for col in tone_cols:
    recall1 = []
    recalln1 = []
    recall0 = []
    fpr1 = []
    fprn1 = []
    fpr0 = []

    for th in thresholds:
        # 임계값에 따른 분류 적용
        doc_predict = use_threshold(filter_doc_predict, col, th)

        # 각 클래스(1, -1, 0)에 대한 재현율 계산
        recall_1 = recall(doc_predict['pred'], doc_predict['answer'], 1)
        recall_neg1 = recall(doc_predict['pred'], doc_predict['answer'], -1)
        recall_0 = recall(doc_predict['pred'], doc_predict['answer'], 0)

        recall1.append(recall_1)
        recalln1.append(recall_neg1)
        recall0.append(recall_0)

        # 각 클래스(1, -1, 0)에 대한 위양성율(FPR) 계산
        fpr_1 = false_positive_rate(doc_predict['pred'], doc_predict['answer'], 1)
        fpr_neg1 = false_positive_rate(doc_predict['pred'], doc_predict['answer'], -1)
        fpr_0 = false_positive_rate(doc_predict['pred'], doc_predict['answer'], 0)

        fpr1.append(fpr_1)
        fprn1.append(fpr_neg1)
        fpr0.append(fpr_0)

    # DataFrame에 저장
    df = pd.DataFrame({
        'threshold': thresholds,
        'column': col,
        'recall1': recall1, 'recalln1': recalln1, 'recall0': recall0,
        'fpr1': fpr1, 'fprn1': fprn1, 'fpr0': fpr0
    })

    results.append(df)

# 모든 결과를 하나의 DataFrame으로 합치기
recallandfpr = pd.concat(results, ignore_index=True)

recallandfpr[0:10001] # tone_i_n2v
recallandfpr[10001:20002] # tone_i_ft
recallandfpr[20002:30003] # tone_i_nb1
recallandfpr[30003:40004] # tone_i_nb2
recallandfpr[40004:50005] # tone_i_kosac

import pandas as pd
import numpy as np
from scipy.integrate import simpson
import matplotlib.pyplot as plt
from matplotlib import font_manager as fm
# 마이너스 기호 처리 (깨지지 않도록 설정)
plt.rcParams['axes.unicode_minus'] = False
# 한글 폰트 설정
font_path = '/content/drive/MyDrive/Colab Notebooks/강원교육모두 Light.ttf'
fm.fontManager.addfont(font_path)
# 폰트를 사용할 수 있게 설정
plt.rcParams['font.family'] = 'GangwonEduAll'


Ngram2Vector = recallandfpr[0:10001] # tone_i_n2v
FastText = recallandfpr[10001:20002] # tone_i_ft
NaiveB1 = recallandfpr[20002:30003] # tone_i_nb1
NaiveB2 = recallandfpr[30003:40004] # tone_i_nb2
KOSAC = recallandfpr[40004:50005] # tone_i_kosac
list_model = [Ngram2Vector, FastText, NaiveB1, NaiveB2, KOSAC]
list_name = ['Ngram2Vector', 'FastText', 'NaiveB1', 'NaiveB2', 'KOSAC']
list_nums = ['recall1','recalln1', 'recall0', 'fpr1', 'fprn1','fpr0']

x = np.linspace(0, 1, 100)  # 0부터 1까지 100개 점 생성
y = x

for idx, model in enumerate(list_model) :
    area_total = 0
    for i in range(3) :
        plt.figure(figsize=(8,6))
        # plt.plot(x, y, linestyle="--", color="red", label="y = x")
        plt.plot(model[list_nums[i+3]], model[list_nums[i]])
        plt.fill_between(model[list_nums[i+3]], model[list_nums[i]], alpha=0.3)

        if  min(model[ list_nums[i+3] ]) != max(model[ list_nums[i+3] ]) :
            plt.xlim(0,max(model[ list_nums[i] ])) # min(model[ list_nums[i] ])
            # plt.xlim(0,1)
        else :
            plt.xlim(0,1)
        if  min(model[ list_nums[i] ]) != max(model[ list_nums[i] ]) :
            plt.ylim(0 ,max(model[ list_nums[i+3] ])) # min(model[ list_nums[i+3] ])
            # plt.ylim(0,1)
        else :
            plt.ylim(0,1)

        plt.xlabel("FPR")
        plt.ylabel("Recall (TPR)")

        if i == 0:
            plt.title(f'ROS Curve: 금리 상승 ({list_name[idx]}, filtered ngram)')
            plt.savefig(f'/content/drive/MyDrive/BOK-TEAM-2/Evaluation/ROS Curve/ROS Curve({list_name[idx]}): 금리 상승(filtered ngram)')
        elif i == 1:
            plt.title(f'ROS Curve: 금리 하락 ({list_name[idx]}, filtered ngram)')
            plt.savefig(f'/content/drive/MyDrive/BOK-TEAM-2/Evaluation/ROS Curve/ROS Curve({list_name[idx]}): 금리 하락(filtered ngram)')
        elif i == 2:
            plt.title(f'ROS Curve: 금리 동결({list_name[idx]}, filtered ngram)')
            plt.savefig(f'/content/drive/MyDrive/BOK-TEAM-2/Evaluation/ROS Curve/ROS Curve({list_name[idx]}): 금리 동결(filtered ngram)')

        # plt.show()
            # 심프슨 방법으로 면적 계산# x와 y 값 정렬 (x 값이 증가하는 순으로 정렬)
        sorted_x, sorted_y = zip(*sorted(zip(model[list_nums[i + 3]], np.abs(model[list_nums[i]]))))
            # 정렬된 x, y로 심프슨 방법으로 면적 계산
        area_simpson = simpson(y=sorted_y, x=sorted_x)
        area_total += area_simpson
        print(f"{list_name[idx]} - 심프슨 방법으로 구한 면적:", area_simpson)
    print(f'Average AUC: {round(area_total/3, 4)}')

# chatgpt
for idx, model in enumerate(list_model):
    area_total = 0  # 평균 AUC 계산용
    for i in range(3):
        plt.figure(figsize=(10, 6))

        # NaN 제거 후 데이터 확인
        model_clean = model[[list_nums[i], list_nums[i+3]]].dropna()
        if model_clean.empty:
            print(f"{list_name[idx]} - {list_nums[i]} 데이터 없음. 그래프 생략.")
            continue  # 데이터 없으면 그래프 그리지 않음

        # 그래프 그리기
        plt.plot(model_clean[list_nums[i]], model_clean[list_nums[i+3]])
        plt.fill_between(model_clean[list_nums[i]], model_clean[list_nums[i+3]], alpha=0.3)

        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.xlabel("Recall")
        plt.ylabel("FPR")

        if i == 0:
            plt.title(f'ROS Curve: 금리 상승 {list_name[idx]}')
        elif i == 1:
            plt.title(f'ROS Curve: 금리 하락 {list_name[idx]}')
        elif i == 2:
            plt.title(f'ROS Curve: 금리 동결 {list_name[idx]}')

        plt.show()

        # 심프슨 방법으로 면적 계산 (NaN 제거 후 정렬)
        sorted_x, sorted_y = zip(*sorted(zip(model_clean[list_nums[i+3]], np.abs(model_clean[list_nums[i]])))) if not model_clean.empty else ([], [])

        # 빈 데이터 체크
        if len(sorted_x) == 0 or len(sorted_y) == 0:
            print(f"{list_name[idx]} - {list_nums[i]} 면적 계산 불가 (데이터 없음).")
            continue  # 다음 루프로 이동

        # 적분 수행
        area_simpson = simpson(y=sorted_y, x=sorted_x)
        area_total += area_simpson
        print(f"{list_name[idx]} - 심프슨 방법으로 구한 면적:", area_simpson)
    print(f'{list_name[idx]} - Average AUC: {area_total/ 3:.4f}')